import React, { useState, useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import api from '../../services/api';
import MaskingForm from './MaskingForm';
import TextPreview from './TextPreview';
import { useNotification } from '../../context/NotificationContext';
import Loader from '../Common/Loader';
import './Masking.css';

const MaskingPage = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { addToast } = useNotification();

  // State
  const [documents, setDocuments] = useState([]);
  const [activeDocIndex, setActiveDocIndex] = useState(0);
  const [maskingData, setMaskingData] = useState({
    policyNumber: '', contractor: '', vat: '', fiscalCode: '', insured: '',
    address: '', city: '', cap: '', other: ''
  });
  const [options, setOptions] = useState({
    policyType: 'rc_generale',
    analysisLevel: 'cliente',
    model: 'gemini-3-flash-preview'
  });

  // OCR Loading state with progress
  const [loading, setLoading] = useState(true);
  const [ocrProgress, setOcrProgress] = useState({
    current: 0,
    total: 0,
    retries: 0,
    currentFile: '',
    timedOut: false
  });

  // Load docs from previous step (Upload)
  useEffect(() => {
    let mounted = true;

    const fetchDocuments = async () => {
      // Only fetch if we have IDs and haven't loaded yet
      if (location.state?.document_ids) {
        try {
          const ids = location.state.document_ids;
          const docs = [];

          setOcrProgress(prev => ({ ...prev, total: ids.length }));

          for (let i = 0; i < ids.length; i++) {
            const id = ids[i];
            if (!mounted) break;

            setOcrProgress(prev => ({
              ...prev,
              current: i + 1,
              retries: 0,
              currentFile: `Documento ${i + 1}`,
              timedOut: false
            }));

            let retries = 0;
            let docData = null;
            const MAX_RETRIES = 60; // 60 retry × 2s = 120 secondi (era 20 = 40s)

            // Poll for text availability (max 120 seconds)
            while (retries < MAX_RETRIES && mounted) {
              try {
                setOcrProgress(prev => ({ ...prev, retries: retries + 1 }));

                const { data } = await api.get(`/documents/${id}/text`);
                docData = data;
                break; // Success
              } catch (e) {
                if (e.response && e.response.status === 404) {
                  // Text not ready yet, wait and retry
                  await new Promise(r => setTimeout(r, 2000));
                  retries++;
                } else {
                  // Retry on network errors too
                  await new Promise(r => setTimeout(r, 2000));
                  retries++;
                }
              }
            }

            if (docData) {
              docs.push({
                id: docData.id,
                filename: docData.filename,
                text_preview: docData.text,
                token_count: docData.token_count
              });
            } else {
              // Timeout reached
              setOcrProgress(prev => ({ ...prev, timedOut: true }));
              addToast(`Timeout attesa OCR per documento ${id} (${retries * 2}s). Riprova con refresh.`, 'error');
            }
          }

          if (mounted) {
            if (docs.length > 0) {
              setDocuments(docs);
              addToast(`${docs.length} documento/i caricato/i con successo`, 'success');
            } else {
              // No documents loaded after retry
              addToast("Nessun documento caricato. L'OCR sta impiegando troppo tempo.", "error");
            }
            setLoading(false);
          }

        } catch (err) {
          console.error("Fetch docs error", err);
          if (mounted) {
            addToast('Errore caricamento documenti', 'error');
            setLoading(false);
          }
        }
      } else if (location.state?.documents) {
        // Docs already loaded, skip OCR polling
        if (mounted) {
          setDocuments(location.state.documents);
          setLoading(false);
        }
      } else {
        // No state passed, redirect to upload
        if (mounted) {
          setLoading(false);
          navigate('/upload');
        }
      }
    };

    fetchDocuments();

    return () => { mounted = false; };
  }, [location.state, navigate, addToast]);

  // Read policyType and analysisLevel from navigation state
  useEffect(() => {
    if (location.state?.policyType) {
      setOptions(prev => ({ ...prev, policyType: location.state.policyType }));
    }
    if (location.state?.analysisLevel) {
      setOptions(prev => ({ ...prev, analysisLevel: location.state.analysisLevel }));
    }
  }, [location.state]);

  const handleStartAnalysis = async () => {
    try {
      const isCompare = location.state?.isCompare;

      // Construct payload based on mode
      const payload = {
        document_ids: documents.map(d => d.id),
        policy_type: options.policyType,
        llm_model: options.model,
        masking_data: maskingData
      };

      if (!isCompare) {
        payload.analysis_level = options.analysisLevel;
      }

      // Use compare endpoint if in comparison mode
      const endpoint = isCompare ? '/compare/start' : '/analysis/start';
      const { data } = await api.post(endpoint, payload);

      addToast(isCompare ? 'Confronto avviato' : 'Analisi avviata con successo', 'success');
      navigate(`/analysis/${data.analysis_id}`);
    } catch (err) {
      console.error('Analysis start error:', err);
      const errorMessage = err.response?.data?.detail || err.message || 'Impossibile avviare analisi';
      addToast(`Errore: ${errorMessage}`, 'error');
    }
  };

  const handleRetryOCR = () => {
    // Reload page to retry OCR
    window.location.reload();
  };

  // Loading state with detailed progress
  if (loading) {
    if (!documents.length && ocrProgress.total > 0) {
      // OCR in progress
      return (
        <div style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100%',
          flexDirection: 'column',
          gap: '24px',
          padding: '40px'
        }}>
          <Loader size="large" />

          <div style={{ textAlign: 'center', maxWidth: '600px' }}>
            <h2 style={{ color: '#0F1F3F', marginBottom: '16px' }}>
              Estrazione testo in corso...
            </h2>

            <div style={{
              background: '#F0F2F5',
              borderRadius: '12px',
              padding: '24px',
              marginBottom: '16px'
            }}>
              <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                marginBottom: '12px',
                fontSize: '14px',
                color: '#64748b'
              }}>
                <span>Progresso</span>
                <span>{ocrProgress.current} di {ocrProgress.total} documenti</span>
              </div>

              <div style={{
                width: '100%',
                height: '8px',
                background: '#E0E0E0',
                borderRadius: '4px',
                overflow: 'hidden'
              }}>
                <div style={{
                  width: `${(ocrProgress.current / ocrProgress.total) * 100}%`,
                  height: '100%',
                  background: 'linear-gradient(135deg, #3B82F6, #8B5CF6)',
                  transition: 'width 0.3s ease'
                }} />
              </div>

              <div style={{
                marginTop: '16px',
                fontSize: '13px',
                color: '#64748b'
              }}>
                <div>{ocrProgress.currentFile}</div>
                <div style={{ marginTop: '4px' }}>
                  Tentativo {ocrProgress.retries} di 60 (max 120 secondi)
                </div>
              </div>
            </div>

            <p style={{ color: '#64748b', fontSize: '14px', lineHeight: '1.6' }}>
              L'estrazione OCR può richiedere fino a 2 minuti per documento,
              specialmente per file scansionati o di grandi dimensioni.
            </p>

            {ocrProgress.timedOut && (
              <div style={{
                marginTop: '24px',
                padding: '16px',
                background: '#FEF2F2',
                border: '1px solid #FCA5A5',
                borderRadius: '8px',
                color: '#DC2626'
              }}>
                <strong>Timeout raggiunto</strong>
                <p style={{ margin: '8px 0 0 0', fontSize: '14px' }}>
                  L'OCR sta impiegando più tempo del previsto.
                  Prova a ricaricare la pagina o contatta il supporto.
                </p>
                <button
                  onClick={handleRetryOCR}
                  style={{
                    marginTop: '12px',
                    padding: '8px 16px',
                    background: '#DC2626',
                    color: 'white',
                    border: 'none',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    fontSize: '14px',
                    fontWeight: '500'
                  }}
                >
                  Ricarica e Riprova
                </button>
              </div>
            )}
          </div>
        </div>
      );
    }

    // Generic loading (no OCR progress yet)
    return (
      <div style={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        height: '100%',
        flexDirection: 'column',
        gap: '16px'
      }}>
        <Loader size="large" />
        <div style={{ textAlign: 'center', color: '#64748b' }}>
          <h3>Caricamento documenti in corso...</h3>
          <p>Attendere prego.</p>
        </div>
      </div>
    );
  }

  // No documents loaded (error state)
  if (!documents.length) {
    return (
      <div style={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        height: '100%',
        flexDirection: 'column',
        gap: '24px',
        padding: '40px'
      }}>
        <div style={{
          textAlign: 'center',
          maxWidth: '500px',
          padding: '32px',
          background: '#FEF2F2',
          border: '1px solid #FCA5A5',
          borderRadius: '12px'
        }}>
          <h2 style={{ color: '#DC2626', marginBottom: '16px' }}>
            Nessun documento caricato
          </h2>
          <p style={{ color: '#64748b', marginBottom: '24px' }}>
            L'estrazione OCR non è riuscita o ha superato il timeout.
          </p>
          <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
            <button
              onClick={() => navigate('/upload')}
              style={{
                padding: '12px 24px',
                background: '#0F1F3F',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                fontSize: '14px',
                fontWeight: '500'
              }}
            >
              Torna all'Upload
            </button>
            <button
              onClick={handleRetryOCR}
              style={{
                padding: '12px 24px',
                background: 'transparent',
                color: '#0F1F3F',
                border: '1px solid #0F1F3F',
                borderRadius: '8px',
                cursor: 'pointer',
                fontSize: '14px',
                fontWeight: '500'
              }}
            >
              Riprova OCR
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Main masking interface
  return (
    <div className="masking-layout fade-in">
      <div className="masking-controls">
        <h2>Mascheramento e Configurazione</h2>

        {/* File Tabs */}
        <div className="file-tabs">
          {documents.map((doc, idx) => (
            <button
              key={doc.id}
              className={`tab-btn ${idx === activeDocIndex ? 'active' : ''}`}
              onClick={() => setActiveDocIndex(idx)}
            >
              {doc.filename}
            </button>
          ))}
        </div>

        <MaskingForm
          data={maskingData}
          onChange={setMaskingData}
          options={options}
          onOptionsChange={setOptions}
          onSubmit={handleStartAnalysis}
          isCompare={location.state?.isCompare || false}
        />
      </div>

      <div className="masking-preview">
        <TextPreview
          text={documents[activeDocIndex]?.text_preview || ''}
          maskingData={maskingData}
        />
      </div>
    </div>
  );
};

export default MaskingPage;
